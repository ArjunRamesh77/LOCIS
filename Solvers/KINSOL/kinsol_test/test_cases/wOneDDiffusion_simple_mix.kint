# 1D steady state non-linear diffusion equation
# d2C/dx2 = -K*C
# Dirichlet conditions on both ends

THREAD SIMPLE_ONE_D_DIFFUSION1
	ROUTINE SETSIZE
		NVAR = 100;
		NEQ = 100;
	END 

	ROUTINE SETGUESS
		for (int i = 0; i < NVAR; i++)
		{
			guess[i] = 0.1;
		}
	END 

	ROUTINE SETOPTIONS
		options->GlobalStrategy = 0;
		options->LinearSolver = "KINDENSE";
		options->FuncNormTolerance = 1.e-5;
		options->ScaledStepTol = 1.e-5;
		options->MaxSetupCalls = 1;
		options->if_jacobian = 1;
		options->finalstatsPrintLevel = 0;
	END 
	
	ROUTINE RESFUNC
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;
		
		// Left Node
		r[0] = x[0] - 1.0;

		// Central Nodes
		for(int i = 1; i <= 98; i++)
			r[i] = x[i-1] - 2*x[i] + x[i+1] + 2*K*x[i]*x[i]*dx*dx;

		// right Node
		r[99] = x[99] - 0.5;
			
	END 

	ROUTINE JACFUNC
		adouble ax[100];
		adouble ay[100];
		double oy[100];
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;

		trace_on(1);
		
		for(int i = 0; i < 100; i++)
			ax[i] <<= x[i];
		
		ay[0] = ax[0] - 1.0;
		for(int i = 1; i <= 98; i++)
			ay[i] = ax[i-1] - 2*ax[i] + ax[i+1] + 2*K*ax[i]*ax[i]*dx*dx;
		ay[99] = ax[99] - 0.5;
		
		for(int i = 0; i < 100; i++)
			ay[i] >>= oy[i];
			
		trace_off();

		jacobian(1, 100, 100, x, J);
	END 

	ROUTINE INFO
		
	END
		
	ROUTINE ERR
		return 0;
	END

END  

THREAD SIMPLE1
	ROUTINE SETSIZE
		NVAR = 2;
		NEQ = 2;
	END 

	ROUTINE SETGUESS
		for (int i = 0; i < NVAR; i++)
		{
			guess[i] = 0.1;
		}
	END 

	ROUTINE SETOPTIONS
		options->GlobalStrategy = 0;
		options->LinearSolver = "KINDENSE";
		options->FuncNormTolerance = 1.e-5;
		options->ScaledStepTol = 1.e-5;
		options->MaxSetupCalls = 1;
		options->if_jacobian = 1;
		options->finalstatsPrintLevel = 0;
	END 
	
	ROUTINE RESFUNC
		r[0] = x[0] * x[1] + 2 * x[0] + 3.0;
		r[1] = (x[1] + x[0])*(x[1] - x[0]) + 72.9;
	END 

	ROUTINE JACFUNC
		adouble ax[2];
		adouble ay[2];
		double oy[2];

		trace_on(1);
		ax[0] <<= x[0];
		ax[1] <<= x[1];

		ay[0] = ax[0] * ax[1] + 2 * ax[0] + 3.0;
		ay[1] = (ax[1] + ax[0])*(ax[1] - ax[0]) + 72.9;

		ay[0] >>= oy[0];
		ay[1] >>= oy[1];
		trace_off();

		jacobian(1, 2, 2, x, J);
	END 

	ROUTINE INFO
		
	END
		
	ROUTINE ERR
		return 0;
	END

END

THREAD SIMPLE2
	ROUTINE SETSIZE
		NVAR = 2;
		NEQ = 2;
	END 

	ROUTINE SETGUESS
		for (int i = 0; i < NVAR; i++)
		{
			guess[i] = 0.1;
		}
	END 

	ROUTINE SETOPTIONS
		options->GlobalStrategy = 0;
		options->LinearSolver = "KINDENSE";
		options->FuncNormTolerance = 1.e-5;
		options->ScaledStepTol = 1.e-5;
		options->MaxSetupCalls = 1;
		options->if_jacobian = 1;
		options->finalstatsPrintLevel = 0;
	END 
	
	ROUTINE RESFUNC
		r[0] = x[0] * x[1] + 2 * x[0] + 3.0;
		r[1] = (x[1] + x[0])*(x[1] - x[0]) + 72.9;
	END 

	ROUTINE JACFUNC
		adouble ax[2];
		adouble ay[2];
		double oy[2];

		trace_on(1);
		ax[0] <<= x[0];
		ax[1] <<= x[1];

		ay[0] = ax[0] * ax[1] + 2 * ax[0] + 3.0;
		ay[1] = (ax[1] + ax[0])*(ax[1] - ax[0]) + 72.9;

		ay[0] >>= oy[0];
		ay[1] >>= oy[1];
		trace_off();

		jacobian(1, 2, 2, x, J);
	END 

	ROUTINE INFO
		
	END
		
	ROUTINE ERR
		return 0;
	END

END

THREAD SIMPLE_ONE_D_DIFFUSION2
	ROUTINE SETSIZE
		NVAR = 100;
		NEQ = 100;
	END 

	ROUTINE SETGUESS
		for (int i = 0; i < NVAR; i++)
		{
			guess[i] = 0.1;
		}
	END 

	ROUTINE SETOPTIONS
		options->GlobalStrategy = 0;
		options->LinearSolver = "KINDENSE";
		options->FuncNormTolerance = 1.e-5;
		options->ScaledStepTol = 1.e-5;
		options->MaxSetupCalls = 1;
		options->if_jacobian = 1;
		options->finalstatsPrintLevel = 0;
	END 
	
	ROUTINE RESFUNC
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;
		
		// Left Node
		r[0] = x[0] - 1.0;

		// Central Nodes
		for(int i = 1; i <= 98; i++)
			r[i] = x[i-1] - 2*x[i] + x[i+1] + 2*K*x[i]*x[i]*dx*dx;

		// right Node
		r[99] = x[99] - 0.5;
			
	END 

	ROUTINE JACFUNC
		adouble ax[100];
		adouble ay[100];
		double oy[100];
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;

		trace_on(1);
		
		for(int i = 0; i < 100; i++)
			ax[i] <<= x[i];
		
		ay[0] = ax[0] - 1.0;
		for(int i = 1; i <= 98; i++)
			ay[i] = ax[i-1] - 2*ax[i] + ax[i+1] + 2*K*ax[i]*ax[i]*dx*dx;
		ay[99] = ax[99] - 0.5;
		
		for(int i = 0; i < 100; i++)
			ay[i] >>= oy[i];
			
		trace_off();

		jacobian(1, 100, 100, x, J);
	END 

	ROUTINE INFO
		
	END
		
	ROUTINE ERR
		return 0;
	END

END  

THREAD SIMPLE_ONE_D_DIFFUSION3
	ROUTINE SETSIZE
		NVAR = 100;
		NEQ = 100;
	END 

	ROUTINE SETGUESS
		for (int i = 0; i < NVAR; i++)
		{
			guess[i] = 0.1;
		}
	END 

	ROUTINE SETOPTIONS
		options->GlobalStrategy = 0;
		options->LinearSolver = "KINDENSE";
		options->FuncNormTolerance = 1.e-5;
		options->ScaledStepTol = 1.e-5;
		options->MaxSetupCalls = 1;
		options->if_jacobian = 1;
		options->finalstatsPrintLevel = 0;
	END 
	
	ROUTINE RESFUNC
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;
		
		// Left Node
		r[0] = x[0] - 1.0;

		// Central Nodes
		for(int i = 1; i <= 98; i++)
			r[i] = x[i-1] - 2*x[i] + x[i+1] + 2*K*x[i]*x[i]*dx*dx;

		// right Node
		r[99] = x[99] - 0.5;
			
	END 

	ROUTINE JACFUNC
		adouble ax[100];
		adouble ay[100];
		double oy[100];
		
		//Parameters
		double K = 1.0;
		double dx = 1.0/99.0;

		trace_on(1);
		
		for(int i = 0; i < 100; i++)
			ax[i] <<= x[i];
		
		ay[0] = ax[0] - 1.0;
		for(int i = 1; i <= 98; i++)
			ay[i] = ax[i-1] - 2*ax[i] + ax[i+1] + 2*K*ax[i]*ax[i]*dx*dx;
		ay[99] = ax[99] - 0.5;
		
		for(int i = 0; i < 100; i++)
			ay[i] >>= oy[i];
			
		trace_off();

		jacobian(1, 100, 100, x, J);
	END 

	ROUTINE INFO
		
	END
		
	ROUTINE ERR
		return 0;
	END

END  

