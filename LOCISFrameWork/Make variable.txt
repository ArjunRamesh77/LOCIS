///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Creates a variable based on domain Data
int FEMOneDLineObject::createVariable(std::string name, std::vector<std::string> domain_names)
{
	//check if variable name exists
	if (getModelEntity(NULL, name) == NULL)
	{
		//Loop over the domains in the model
		auto f = domains.find("!@#$");
		int totalNumEl = 0;
		int retval;
		for (auto dn = domain_names.begin(); dn != domain_names.end(); ++dn)
		{
			f = domains.find(*dn);
			if (f != domains.end())
			{
				retval = getNumNodesFromElementType(f->second.iNumberOfElements);
				if (retval > 0)
				{
					totalNumEl += retval;
				}
				else
				{
					return SY_FAIL;
				}
			}
			else
			{
				return SY_FAIL;
			}
		}

		//Create the variable
		Variable* var;
		Variable* dvar;

		// Regular
		var = new Variable;
		var->setNType(REAL);
		var->setName(name);
		var->setType(VARIABLE);
		var->setSType("VARIABLE");

		// Time dependent
		dvar = new Variable;
		dvar->setNType(REAL);
		dvar->setName("$" + name);
		dvar->setType(VARIABLE);
		dvar->setSType("VARIABLE");
		dvar->setIsdt();

		// Set signature to FEM oneD type variable
		var->isFEMOneDVariable = true;
		dvar->isFEMOneDdVariable = true;

		// Give each others reference to each other
		dvar->other = var;
		var->other = dvar;

		// Fem variables are always vectors
		var->setDimType(SY_VECTOR);
		dvar->setDimType(SY_VECTOR);

		// Add to Line model
		if (!insertModelEntity(name, var) || !insertModelEntity("$" + name, dvar))
		{
			return SY_FAIL;
		}
		
		// Add data to domain
		int start_index, end_index = 0;
		for (auto dn = domain_names.begin(); dn != domain_names.end(); ++dn)
		{
			f = domains.find(*dn);
			if (f != domains.end())
			{
				auto f2 = f->second.domainVars.find(name);
				if (f2 == f->second.domainVars.end())
				{
					FEMOneDVariableDomainData vDD;
					
					// Add references
					vDD.var = var;
					vDD.dvar = dvar;

					// Find boundary indices
					if (calculateBoundaryNodeNumbers(f->second.order, start_index, end_index))
					{
						vDD.domainSize["left"] = start_index;
						vDD.domainSize["right"] = end_index;
					}
					else
					{
						return SY_FAIL;
					}

					// Add the variable data to the domain
					f->second.domainVars[name] = vDD;
				}
				else
				{
					return SY_FAIL;
				}
			}
			else
			{
				return SY_FAIL;
			}
		}
	}
	else
	{
		return SY_FAIL;
	}
}